{"/creational-patterns":{"title":"Creational Patterns","data":{"":"Creational patterns are the way of creating objects, which increase flexibility and reuse of existing code.","types-of-creational-patterns#Types of Creational Patterns":"Simple Factory\nFactory Method\nAbstract Factory\nBuilder\nPrototype\nSingleton"}},"/creational-patterns/factory-method":{"title":"Factory Method","data":{"":"Factory Method is the way of delegating the object creation logic to the client.\nReal world example\nConsider the case of a bank. It's possible for both local and foreigner to open a bank account. So the bank has to delegate the register account steps to them.\nExampleBankAccount interface and implementations\ninterface BankAccount {\n  public void registerAccount();\n}\nclass LocalAccount implements BankAccount {\n  public void registerAccount() {\n    System.out.println(\"Registering account for local.\");\n  }\n}\nclass ForeigneAccount implements BankAccount {\n  public void registerAccount() {\n    System.out.println(\"Registering account for foreigner.\");\n  }\n}\nBank\nabstract class Bank {\n  abstract protected BankAccount makeBankAccount();\n  \n  public void openBankAccount() {\n    BankAccount bankAccount = this.makeBankAccount();\n    bankAccount.registerAccount();\n  }\n}\nAny child can extend it and provide the required BankAccount\nclass LocalBankAccount extends Bank {\n  protected BankAccount makeBankAccount() {\n    return new LocalAccount();\n  }\n}\nclass ForeigneBankAccount extends Bank {\n  protected BankAccount makeBankAccount() {\n    return new ForeigneAccount();\n  }\n}\nIt can be used as\nLocalBankAccount local = new LocalBankAccount();\nlocal.openBankAccount(); // Output: Registering account for local\nForeigneBankAccount roreigner = new ForeigneBankAccount();\nroreigner.openBankAccount(); // Output: Registering account for foreigner"}},"/creational-patterns/introduction":{"title":"Creational Patterns","data":{"":"Creational patterns are the way of creating objects, which increase flexibility and reuse of existing code.","types-of-creational-patterns#Types of Creational Patterns":"Simple Factory\nFactory Method\nAbstract Factory\nBuilder\nPrototype\nSingleton"}},"/creational-patterns/simple-factory":{"title":"Simple Factory","data":{"":"Simple Factory is the way of creating objects to encapsulate the logic of entity. Client doesn't know the actual logic of entity.\nSimple Factory is the way of creating objects for client without exposing the object creation logic to the client.\nReal world example\nLet's consider, you want a Mac laptop. You simply can get one from a factory so you don't need to learn anything about making the laptop.\nExampleLaptop interface and the implementation\ninterface Laptop {\n  public int getScreenSize();\n}\nclass MacLaptop implements Laptop {\n  protected int screenSize;\n  public MacLaptop(int screenSize) {\n    this.screenSize = screenSize;\n  }\n  public int getScreenSize() {\n    return this.screenSize;\n  }\n}\nLaptop factory that make the laptop\nclass LaptopFactory {\n  public static Laptop makeLaptop(int screenSize) {\n    return new MacLaptop(screenSize);\n  }\n}\nIt can be used\n// Make me a 14 inch laptop\nLaptop macLaptop = LaptopFactory.makeLaptop(14);\nSystem.out.println(macLaptop.getScreenSize());\nSource Code in Java"}},"/":{"title":"Introduction","data":{"":"Design patterns are proven solutions to tackle particular problems in software design.","types-of-design-patterns#Types of Design Patterns":"Creational\nStructural\nBehavioral"}}}